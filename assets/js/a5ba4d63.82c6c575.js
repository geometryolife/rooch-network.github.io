"use strict";(self.webpackChunkrooch_network=self.webpackChunkrooch_network||[]).push([[3960],{4137:(t,e,o)=>{o.d(e,{Zo:()=>l,kt:()=>h});var r=o(7294);function n(t,e,o){return e in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}function a(t,e){var o=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.push.apply(o,r)}return o}function c(t){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?a(Object(o),!0).forEach((function(e){n(t,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))}))}return t}function i(t,e){if(null==t)return{};var o,r,n=function(t,e){if(null==t)return{};var o,r,n={},a=Object.keys(t);for(r=0;r<a.length;r++)o=a[r],e.indexOf(o)>=0||(n[o]=t[o]);return n}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)o=a[r],e.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(t,o)&&(n[o]=t[o])}return n}var s=r.createContext({}),u=function(t){var e=r.useContext(s),o=e;return t&&(o="function"==typeof t?t(e):c(c({},e),t)),o},l=function(t){var e=u(t.components);return r.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},f=r.forwardRef((function(t,e){var o=t.components,n=t.mdxType,a=t.originalType,s=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),f=u(o),h=n,d=f["".concat(s,".").concat(h)]||f[h]||p[h]||a;return o?r.createElement(d,c(c({ref:e},l),{},{components:o})):r.createElement(d,c({ref:e},l))}));function h(t,e){var o=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var a=o.length,c=new Array(a);c[0]=f;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=t,i.mdxType="string"==typeof t?t:n,c[1]=i;for(var u=2;u<a;u++)c[u]=o[u];return r.createElement.apply(null,c)}return r.createElement.apply(null,o)}f.displayName="MDXCreateElement"},5723:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var r=o(3117),n=(o(7294),o(4137));const a={},c="Transaction Accumulator Proofs",i={unversionedId:"technology/transaction-accumulator-proofs",id:"technology/transaction-accumulator-proofs",title:"Transaction Accumulator Proofs",description:"Transaction accumulator proofs provide proof that a transaction is in a certain position. Suppose the sequencer tampered with the order of a transaction or dropped a transaction. In that case, the user or verifier can initiate arbitration with the arbitration layer contract via the transaction accumulator proof.",source:"@site/docs/04-technology/03-transaction-accumulator-proofs.md",sourceDirName:"04-technology",slug:"/technology/transaction-accumulator-proofs",permalink:"/docs/technology/transaction-accumulator-proofs",draft:!1,editUrl:"https://github.com/rooch-network/rooch-network.github.io/edit/main/docs/04-technology/03-transaction-accumulator-proofs.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Fraud Proofs",permalink:"/docs/technology/fraud-proofs"},next:{title:"Decentralized validator network",permalink:"/docs/technology/decentralized-validator-network"}},s={},u=[{value:"How accumulators work",id:"how-accumulators-work",level:2},{value:"Interaction flow for transaction accumulator proofs",id:"interaction-flow-for-transaction-accumulator-proofs",level:2}],l={toc:u};function p(t){let{components:e,...a}=t;return(0,n.kt)("wrapper",(0,r.Z)({},l,a,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"transaction-accumulator-proofs"},"Transaction Accumulator Proofs"),(0,n.kt)("p",null,"Transaction accumulator proofs provide proof that a transaction is in a certain position. Suppose the sequencer tampered with the order of a transaction or dropped a transaction. In that case, the user or verifier can initiate arbitration with the arbitration layer contract via the transaction accumulator proof."),(0,n.kt)("h2",{id:"how-accumulators-work"},"How accumulators work"),(0,n.kt)("p",null,"The accumulator used in Rooch is the MerkleAccumulator, an accumulator implemented through the Merkle Tree. It has the proof ability of a Merkle Tree, providing proof of the position of a leaf node under a certain root node, and is used in Rooch to implement transaction position proofs."),(0,n.kt)("p",null,"The Merkle accumulator has been used in Starcoin to provide position proofs for transactions and blocks. For a detailed technical implementation refer to the ",(0,n.kt)("a",{parentName:"p",href:"https://cookbook.starcoin.org/zh/docs/concepts/accumulator/"},"Starcoin Cookbook Accumulator chapter"),"."),(0,n.kt)("h2",{id:"interaction-flow-for-transaction-accumulator-proofs"},"Interaction flow for transaction accumulator proofs"),(0,n.kt)("p",null,"When the user submits a transaction to the sequencer, the sequencer returns to the user the result of the execution, as well as the root of the accumulator and the proof of the position of the transaction after it is added to the accumulator, with sequencer\u2018s signature."),(0,n.kt)("p",null,"The root of the accumulator is recorded in the consensus layer and verified by the consensus layer. Suppose the user finds that the order of the transactions recorded in the consensus layer does not match the order of the transactions when he submits them. In that case, he can initiates arbitration with the arbitration layer via the transaction accumulator proof."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"secure txn confirmation",src:o(3629).Z,width:"712",height:"427"})))}p.isMDXComponent=!0},3629:(t,e,o)=>{o.d(e,{Z:()=>r});const r=o.p+"assets/images/rooch-secure-txn-confirmation-eb608efc0447e6f1c24799dc65f6c191.svg"}}]);