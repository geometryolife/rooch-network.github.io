"use strict";(self.webpackChunkrooch_network=self.webpackChunkrooch_network||[]).push([[3941],{4137:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>h});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),y=l(o),h=r,d=y["".concat(c,".").concat(h)]||y[h]||p[h]||a;return o?n.createElement(d,i(i({ref:t},u),{},{components:o})):n.createElement(d,i({ref:t},u))}));function h(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=y;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=o[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}y.displayName="MDXCreateElement"},8599:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=o(3117),r=(o(7294),o(4137));const a={},i="Cross Layer Interoperability",s={unversionedId:"technology/move-on-rooch/cross-layer-interoperability",id:"technology/move-on-rooch/cross-layer-interoperability",title:"Cross Layer Interoperability",description:"Cross-layer interoperability is one of the challenges in a layered solution, and the following solutions for cross-layer interaction are provided in Rooch.",source:"@site/docs/04-technology/07-move-on-rooch/01-cross-layer-interoperability.md",sourceDirName:"04-technology/07-move-on-rooch",slug:"/technology/move-on-rooch/cross-layer-interoperability",permalink:"/docs/technology/move-on-rooch/cross-layer-interoperability",draft:!1,editUrl:"https://github.com/rooch-network/rooch-network.github.io/edit/main/docs/04-technology/07-move-on-rooch/01-cross-layer-interoperability.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Why Move?",permalink:"/docs/technology/move-on-rooch/"},next:{title:"Account Abstraction",permalink:"/docs/technology/move-on-rooch/account-abstraction"}},c={},l=[{value:"Cross-layer message communication",id:"cross-layer-message-communication",level:2},{value:"Cross-layer contract dependencies",id:"cross-layer-contract-dependencies",level:2},{value:"Cross-layer function invoke",id:"cross-layer-function-invoke",level:2},{value:"Continuation of state types",id:"continuation-of-state-types",level:2}],u={toc:l};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cross-layer-interoperability"},"Cross Layer Interoperability"),(0,r.kt)("p",null,"Cross-layer interoperability is one of the challenges in a layered solution, and the following solutions for cross-layer interaction are provided in Rooch."),(0,r.kt)("h2",{id:"cross-layer-message-communication"},"Cross-layer message communication"),(0,r.kt)("p",null,"Cross-layer message communication only passes messages and does not rely on state, which is easier to implement and is practiced in current Layer2 solutions."),(0,r.kt)("h2",{id:"cross-layer-contract-dependencies"},"Cross-layer contract dependencies"),(0,r.kt)("p",null,"In Rooch, an application's smart contracts can depend on contracts deployed in Move Layer1, Move Layer1 is Rooch's ",(0,r.kt)("a",{parentName:"p",href:"/docs/technology/modular-blockchain-architecture/"},"Module Repository Layer"),". This brings the potential for improving cross-layer interoperability , as well as building a unified Move application ecosystem."),(0,r.kt)("h2",{id:"cross-layer-function-invoke"},"Cross-layer function invoke"),(0,r.kt)("p",null,"Now that we have implemented cross-layer contract dependencies, we can directly invoke Layer1 function when the application is running in the execution layer or state channel."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"cross layer invoke",src:o(3066).Z,width:"741",height:"440"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the function does not read the on-chain state, it is equivalent to running the bytecode of the on-chain contract in the off-chain virtual machine, and the result depends only on the input parameters."),(0,r.kt)("li",{parentName:"ul"},"If the function reads the on-chain state, it is equivalent to taking a snapshot of the state at the height of Layer1, reading the state from the state snapshot, and computing the result."),(0,r.kt)("li",{parentName:"ul"},"If the function modifies the on-chain state, it needs to use ",(0,r.kt)("a",{parentName:"li",href:"/docs/technology/state-scaling"},"state migration")," and an asynchronous call to achieve cross-layer method invocation. Further research is needed on how to achieve a seamless developer experience.")),(0,r.kt)("h2",{id:"continuation-of-state-types"},"Continuation of state types"),(0,r.kt)("p",null,"In Move, state is identified by type, and Rooch's cross-layer state migration solution ensures continuation of state types and reduces user awareness costs. If Layer1 is an EVM chain, we can simulate the Move state in Solidity to ensure the continuation of contract addresses, this needs further researc. Refer to ",(0,r.kt)("a",{parentName:"p",href:"/docs/technology/state-scaling"},"State Migration")," for the solution."))}p.isMDXComponent=!0},3066:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/rooch-cross-layer-invoke-b02f8c59c225c07f833d397a28926ed6.svg"}}]);